<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL搭建主从复制实现细节分析]]></title>
    <url>%2F2017%2F12%2F09%2FMySQL%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概念 主从复制可以使MySQL数据库主服务器的主数据库，复制到一个或多个MySQL从服务器从数据库，默认情况下，复制异步; 根据配置，可以复制数据库中的所有数据库，选定的数据库或甚至选定的表。 MySQL中主从复制的优点横向扩展解决方案在多个从库之间扩展负载以提高性能。在这种环境中，所有写入和更新在主库上进行。但是，读取可能发生在一个或多个从库上。该模型可以提高写入的性能（由于主库专用于更新），同时在多个从库上读取，可以大大提高读取速度。 数据安全性由于主库数据被复制到从库，从库可以暂停复制过程，可以在从库上运行备份服务，而不会破坏对应的主库数据。 分析可以在主库上创建实时数据，而信息分析可以在从库上进行，而不会影响主服务器的性能。 长距离数据分发可以使用复制创建远程站点使用的数据的本地副本，而无需永久访问主库。 1.准备工作Mysql版本：MySQL 5.7.11Master-Server : 192.168.252.123Slave-Server : 192.168.252.124 关闭防火墙 1systemctl stop firewalld.service 安装 MySQL 首先在两台机器上装上，保证正常启动，可以使用 Master-Server 配置修改 my.cnf 配置 Master 以使用基于二进制日志文件位置的复制，必须启用二进制日志记录并建立唯一的服务器ID,否则则无法进行主从复制。 停止MySQL服务。 1service mysql.server stop 开启binlog ，每台设置不同的 server-id 1234$ cat /etc/my.cnf[mysqld]log-bin=mysql-binserver-id=1 启动MySQL服务 1service mysql.server start 登录MySQL 1/usr/local/mysql/bin/mysql -uroot -p 创建用户每个从库使用MySQL用户名和密码连接到主库，因此主库上必须有用户帐户，从库可以连接。任何帐户都可以用于此操作，只要它已被授予 REPLICATION SLAVE权限。可以选择为每个从库创建不同的帐户，或者每个从库使用相同帐户连接到主库 虽然不必专门为复制创建帐户，但应注意，复制用到的用户名和密码会以纯文本格式存储在主信息存储库文件或表中 。因此，需要创建一个单独的帐户，该帐户只具有复制过程的权限，以尽可能减少对其他帐户的危害。 登录MySQL 1/usr/local/mysql/bin/mysql -uroot -p 12mysql&gt; CREATE USER &apos;replication&apos;@&apos;192.168.252.124&apos; IDENTIFIED BY &apos;mima&apos;;mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;replication&apos;@&apos;192.168.252.124&apos;; Slave-Server 配置修改 my.cnf 停止MySQL服务。 1service mysql.server stop 123$ cat /etc/my.cnf[mysqld]server-id=2 如果要设置多个从库，则每个从库的server-id与主库和其他从库设置不同的唯一值。 启动MySQL服务 1service mysql.server start 登录MySQL 配置主库通信 查看 Master-Server ， binlog File 文件名称和 Position值位置 并且记下来 1mysql&gt; show master status; 要设置从库与主库进行通信，进行复制，使用必要的连接信息配置从库在从库上执行以下语句将选项值替换为与系统相关的实际值 参数格式，请勿执行 123456mysql&gt; CHANGE MASTER TO -&gt; MASTER_HOST=&apos;master_host_name&apos;, -&gt; MASTER_USER=&apos;replication_user_name&apos;, -&gt; MASTER_PASSWORD=&apos;replication_password&apos;, -&gt; MASTER_LOG_FILE=&apos;recorded_log_file_name&apos;, -&gt; MASTER_LOG_POS=recorded_log_position; 1234567mysql&gt; CHANGE MASTER TO -&gt; MASTER_HOST=&apos;192.168.252.123&apos;, -&gt; MASTER_USER=&apos;replication&apos;, -&gt; MASTER_PASSWORD=&apos;mima&apos;, -&gt; MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, -&gt; MASTER_LOG_POS=629;Query OK, 0 rows affected, 2 warnings (0.02 sec) MASTER_LOG_POS=0 写成0 也是可以的 放在一行执行方便 1CHANGE MASTER TO MASTER_HOST=&apos;192.168.252.123&apos;, MASTER_USER=&apos;replication&apos;, MASTER_PASSWORD=&apos;mima&apos;, MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;, MASTER_LOG_POS=629; 启动从服务器复制线程 12mysql&gt; START SLAVE;Query OK, 0 rows affected (0.00 sec) 查看复制状态 检查主从复制通信状态 Slave_IO_State #从站的当前状态Slave_IO_Running： Yes #读取主程序二进制日志的I/O线程是否正在运行Slave_SQL_Running： Yes #执行读取主服务器中二进制日志事件的SQL线程是否正在运行。与I/O线程一样Seconds_Behind_Master #是否为0，0就是已经同步了 必须都是 Yes 在mysql5.0以后的版本，mysql主从已经相当的成熟了，可以只监控Slave_IO_Running，Slave_SQL_Running，Seconds_Behind_Master状态就可以了，这里不再做说明。 测试主从复制 启动MySQL服务 登录MySQL 在 Master-Server 创建测试库 123mysql&gt; CREATE DATABASE `replication_wwww.ymq.io`;mysql&gt; use `replication_wwww.ymq.io`;mysql&gt; CREATE TABLE `sync_test` (`id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 在 Slave-Server 查看是否同步过来 123mysql&gt; show databases;mysql&gt; use replication_wwww.ymq.iomysql&gt; show tables; 一些坑 Last_IO_Errno: 1045错误： 解决方案 Connecting and Last_IO_Errno: 2003 错误 解决方案2 Last_Errno: 1008解决方案3 MySQL错误处理–1146错误 解决方案 Last_SQL_Errno：1062 解决方案 参考文档1 mysql主主和主主集群 双主同步，如果服务器意外挂机 MySQL基于日志（binlog）主从复制搭建 MySQL数据库设置主从同步]]></content>
      <categories>
        <category>安全运维</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu配置Shadowsocks实现终端代理]]></title>
    <url>%2F2017%2F12%2F09%2FUbuntu%E9%85%8D%E7%BD%AEShadowsocks%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景场景一： 这几天想配置PHP Laravel框架，Laravel框架需要Composer安装。结果安装Composer的时候遭遇到了GFW，光在浏览器上穿墙还不够，还要在终端上穿墙。使用Shadowsocks在浏览器上穿墙很简单，但是在终端穿墙以前没接触过，这次花了5个小时搞定了。 利用linode翻墙安装相关配置时，哪速度，真是让人怀念。所以在局域网的一台机器上面开始动手了。 场景二： 做开发的同学，应该都会经常接触终端，有些时候我们在终端会做一些网络操作，比如下载gradle包等，由于一些你懂我也懂的原因，某些网络操作不是那么理想，这时候我们就需要设置代理来自由地访问网络。 Shadowsocks是我们常用的代理工具，它使用socks5协议，而终端很多工具目前只支持http和https等协议，对socks5协议支持不够好，所以我们为终端设置shadowsocks的思路就是将socks协议转换成http协议，然后为终端设置即可。仔细想想也算是适配器模式的一种现实应用吧。 想要进行转换，需要借助工具，这里我们采用比较知名的polipo来实现。 polipo是一个轻量级的缓存web代理程序。 前题是，已经在服务器端安装好了相关应用。 Shadowsocks 是一个开源安全的 Socks5 代理，中文名称“影梭“，类似于 SSH 代理。与一度非常流行的基于 GAE 的科学上网方式相比，Shadowsocks 部署简单，使用灵活；同时与全局代理的 VPN 不同，Shadowsocks 可以仅针对浏览器代理，轻巧方便，如果说 VPN 是一把 ==屠龙宝刀==，那么 Shadowsocks 就是一把 ==瑞士军刀==，虽小巧但功能强大。 1.ubuntu安装shadowsocks运行环境安装123sudo apt-get updatesudo apt-get install python-pipsudo apt-get install python-setuptools m2crypto 接着安装shadowsocks 1pip install shadowsocks 如果是ubuntu16.04 直接 (16.04 里可以直接用apt 而不用 apt-get 这是一项改进） 2.启动shadowsocks安装好后，在本地我们要用到sslocal ，终端输入sslocal –help 可以查看帮助，像这样 通过帮助提示我们知道各个参数怎么配置，比如 sslocal -c 后面加上我们的json配置文件，或者像下面这样直接命令参数写上运行。 比如 1sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb -s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加””）, -t超时默认300,-m是加密方法默认aes-256-cfb， 为了方便我推荐直接用sslcoal -c 配置文件路径 这样的方式，简单好用。 我们可以在/home/mudao/ 下新建个文件shadowsocks.json (mudao是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：12345678&#123;&quot;server&quot;:&quot;11.22.33.44&quot;,&quot;server_port&quot;:50003,&quot;local_port&quot;:1080,&quot;password&quot;:&quot;123456&quot;,&quot;timeout&quot;:600,&quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 确定上面的配置文件没有问题，然后我们就可以在终端输入 1sslocal -c /etc/shadowsocks.json 回车运行。如果没有问题的话，下面会是这样… 3.开机后台自动运行ss如果你上面可以代理上网了可以进行这一步，之前我让你不要关掉终端，因为关掉终端的时候代理就随着关闭了，之后你每次开机或者关掉终端之后，下次你再想用代理就要重新在终端输入这样的命令 sslocal -c /home/mudao/shadowsocks.json ，挺麻烦是不？ 我们现在可以在你的ubuntu上安装一个叫做supervisor的程序来管理你的sslocal启动。关于supervisor在前面介绍安装mod-ss-panel时，有介绍！ 1sudo apt-get install supervisor 安装好后我们可以在/etc/supervisor/目录下找到supervisor.conf配置文件，我们可以用以下命令来编辑 1sudo gedit /etc/supervisor/supervisor.conf 在这个文件的最后加上以下内容 1234567[program:shadowsocks]command=sslocal -c /home/mudao/shadowsocks.jsonautostart=trueautorestart=trueuser=rootlog_stderr=truelogfile=/var/log/shadowsocks.log 现在关掉你之前运行sslocal命令的终端，再打开终端输入 1sudo service supervisor restart 然后去打开浏览器看看可不可以继续代理上网。你也可以用 1ps -ef|grep sslocal 命令查看sslocal是否在运行。 这个时候我们需要在/etc下编辑一个叫rc.local的文件 ，让supervisor开机启动。 1sudo gedit /etc/rc.local 在这个配置文件的 1exit 0 前面一行加上 1service supervisor start 保存。 看你是否配置成功你可以在现在关机重启之后直接打开浏览器看是否代理成功。 以上原文引自这里4. 终端穿墙浏览器能穿墙就已经能满足绝大多数需求了，但是有的时候终端也必须穿墙，就比如Composer。关于终端穿墙，本人尝试了很多种方案，比如Privoxy、Proxychains和Polipo，最后选择了Privoxy。 为什么终端需要单独穿墙呢？难道Shadowsock不能“全局”代理么？这个问题当时困惑了我很久，最后一句话点醒了我。 Shadowsocks是一个使用SOCKS5（或者SOCK4之类）协议的代理，它只接受SOCKS5协议的流量，不接受HTTP或者HTTPS的流量。所以当你在Chrome上能穿墙的时候，是Proxy SwitchyOmega插件把HTTP和HTTPS流量转换成了SOCKS协议的流量，才实现了Shadowsocks的代理。而终端是没有这样的协议转换的，所以没法直接使用Shadowsock进行代理。 这时候就需要一个协议转换器，这里我用了Privoxy(我用privoxy没有成功！但是用polipo成功了)。 1~$ sudo apt-get install privoxy 安装好后进行配置，Privoxy的配置文件在/etc/privoxy/config，这个配置文件中注释很多。 找到 1listen-address 这一节，确认监听的端口号(这个端口号要跟1080区分开来，之前没有成功。估计就是因为把这个端口号改了)。 找到5.2. forward-socks4, forward-socks4a, forward-socks5 and forward-socks5t这一节，加上如下配置，注意最后的点号。 有关Privoxy的配置就结束了，重启一下Privoxy。 1~$ sudo /etc/init.d/privoxy restart 接着配置一下终端的环境，需要如下两句。 12~$ export http_proxy=&quot;127.0.0.1:8118&quot;~$ export https_proxy=&quot;127.0.0.1:8118&quot; 为了方便还是在/etc/rc.local中添加如下命令，注意在exit 0之前。 1sudo /etc/init.d/privoxy start 在/etc/profile的末尾添加如下两句。 12export http_proxy=&quot;127.0.0.1:8118&quot;export https_proxy=&quot;127.0.0.1:8118&quot; 安装privoxy的参考原文在这里 5.Shadowsocks 转换 HTTP 代理(使用Polipo)Shadowsocks 默认是用 Socks5 协议的，对于 ==Terminal== 的 get,wget 等走 Http 协议的地方是无能为力的，所以需要转换成 Http 代理，加强通用性，这里使用的转换方法是基于 Polipo 的。 输入命令安装 Polipo： 1sudo apt-get install polipo 修改配置文件： 1sudo gedit /etc/polipo/config 将下面的内容整个替换到文件中并保存： 123456789101112131415161718# This file only needs to list configuration variables that deviate# from the default values. See /usr/share/doc/polipo/examples/config.sample# and &quot;polipo -v&quot; for variables you can tweak and further information.logSyslog = falselogFile = &quot;/var/log/polipo/polipo.log&quot; socksParentProxy = &quot;127.0.0.1:1080&quot;socksProxyType = socks5 chunkHighMark = 50331648objectHighMark = 16384 serverMaxSlots = 64serverSlots = 16serverSlots1 = 32 proxyAddress = &quot;0.0.0.0&quot;proxyPort = 8123 重启 Polipo： 1/etc/init.d/polipo restart 验证代理是否正常工作： 12export http_proxy=&quot;http://127.0.0.1:8123/&quot;curl www.google.com 如果正常，就会返回抓取到的 Google 网页内容。 第二种验证代理是否正常工作的方法： 安装完成就需要进行验证是否work。这里展示一个最简单的验证方法，打开终端，如下执行 123407:56:24-androidyue/var/log$ curl ip.gs当前 IP：125.39.112.15 来自：中国天津天津 联通08:09:23-androidyue/var/log$ http_proxy=http://localhost:8123 curl ip.gs当前 IP：210.140.193.128 来自：日本日本 如上所示，为某个命令设置代理，前面加上http_proxy=http://localhost:8123 后接命令即可。注：8123是polipo的默认端口，如有需要，可以修改成其他有效端口。 当前会话全局设置如果嫌每次为每一个命令设置代理比较麻烦，可以为当前会话设置全局的代理。 即使用 1export http_proxy=http://localhost:8123 即可。 如果想撤销当前会话的http_proxy代理，使用 1unset http_proxy 1234567821:29:49-androidyue~$ curl ip.gs当前 IP：125.39.112.14 来自：中国天津天津 联通21:29:52-androidyue~$ export http_proxy=http://localhost:812321:30:07-androidyue~$ curl ip.gs当前 IP：210.140.193.128 来自：日本日本 21:30:12-androidyue~$ unset http_proxy21:30:37-androidyue~$ curl ip.gs当前 IP：125.39.112.14 来自：中国天津天津 联通 如果想要更长久的设置代理，可以将 12export http_proxy=http://localhost:8123export https_proxy=http://localhost:8123 加入.bashrc或者.bash_profile文件 另外，在浏览器中输入 1http://127.0.0.1:8123/ 便可以进入到 Polipo 的使用说明和配置界面。 设置浏览器和开机启动 最后就是将转换后的 Http 代理设置到浏览器中，地址是 127.0.0.1，端口 8123，代理类型当然是选择 Http 啦。对于 FireFor 用户来说，插件可以选择 AutoProxy 或 FoxyProxy 配置polipo在原文在这里 引申： 6.设置Git代理（接上面的polipo）复杂一些的设置Git代理 12345678git clone https://android.googlesource.com/tools/repo --config http.proxy=localhost:8123Cloning into &apos;repo&apos;...remote: Counting objects: 135, doneremote: Finding sources: 100% (135/135)remote: Total 3483 (delta 1956), reused 3483 (delta 1956)Receiving objects: 100% (3483/3483), 2.63 MiB | 492 KiB/s, done.Resolving deltas: 100% (1956/1956), done. 其实这样还是比较复杂，因为需要记忆的东西比较多， 下面是一个更简单的实现 首先，在.bashrc或者.bash_profile文件加入这一句。 1gp=&quot; --config http.proxy=localhost:8123&quot; 然后 执行source操作，更新当前bash配置。 更简单的使用git的方法 12345678git clone https://android.googlesource.com/tools/repo $gpCloning into &apos;repo&apos;...remote: Counting objects: 135, doneremote: Finding sources: 100% (135/135)remote: Total 3483 (delta 1956), reused 3483 (delta 1956)Receiving objects: 100% (3483/3483), 2.63 MiB | 483 KiB/s, done.Resolving deltas: 100% (1956/1956), done. [在git终端mac终端加入代理原文引自这里]http://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/) 7.apt-get怎么使用代理服务器升级到Ubuntu10.04后，发现apt-get的代理设置有改变了，在9.10以前使用“http_proxy”环境变量就可以令apt-get使用代理. 然后在Ubuntu10.04下就无效了，看来apt-get已经被改成不使用这个环境变量了。 一阵郁闷后，最后我发现在“首选项”-&gt;“网络代理”那里，多了个“System-wide”按钮（我用的是英文环境，不知道中文被翻译成怎样，关闭窗口时也会提示你），在这里设置后，apt-get确实可以使用代理了。 但是我依然鄙视这种改进，因为我通常就是偶尔使用代理，更新几个被墙掉的仓库而已（如dropbox和tor），根本不想使用全局代理，本来用终端就能搞定的事，现在切换代理要点N次鼠标，真烦。 所以我研究了一下，发现那个代理设置修改了两个文件，一个是“/etc/environment”，这个是系统的环境变量，里面定义了“http_proxy”等代理环境变量。另一个是“/etc/apt/apt.conf”，这个就是apt的配置，内容如下 在/etc/apt/apt.conf中追加 123Acquire::http::proxy &quot;http://127.0.0.1:8123/&quot;;Acquire::ftp::proxy &quot;ftp://127.0.0.1:8123/&quot;;Acquire::https::proxy &quot;https://127.0.0.1:8123/&quot;; 很明显的代理设置代码，我看了下apt-get的手册，发现可以用“-c”选项来指定使用配置文件，也就是复制一份为“~/apt_proxy.conf”，然后“网络代理”那里重置回直接连接，以后使用 1sudo apt-get -c ~/apt_proxy.conf update 1sudo apt-get -c ~/apt_proxy.conf install mongodb apt-get 使用代理在的原文在这里]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo + Github Pages搭建个人独立博客]]></title>
    <url>%2F2017%2F12%2F08%2F%E4%BD%BF%E7%94%A8Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[系统环境配置要使用Hexo，需要在你的系统中支持Nodejs以及Git 安装Hexo1234567$ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 这里有必要提下Hexo常用的几个命令：12$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面 常用简写1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 123hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 常用组合12$ hexo d -g #生成部署$ hexo s -g #生成预览 Hexo主题设置 Github Pages设置 什么是Github Pages GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。 部署Hexo到Github Pages 首先需要明白所谓部署到github的原理。 之前步骤中在Github上创建的那个特别的repo（jiji262.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接http://jiji262.github.io来直接访问。 Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。需要将hexo生成的静态网站，提交(git commit)到github上。明白了原理，怎么做自然就清晰了. 使用hexo deploy部署hexo deploy可以部署到很多平台，具体可以参考这个链接. 如果部署到github，需要在配置文件_config.xml中作如下修改： 1234deploy: type: git repo: git@github.com:jiji262/jiji262.github.io.git branch: master 然后在命令行中执行 1hexo d 即可完成部署。 踩坑提醒 注意需要提前安装一个扩展： 1$ npm install hexo-deployer-git --save Hexo 主题配置参考文档1]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
